{"version":3,"sources":["webpack:///./lib/minesweeper.js"],"names":["playing","newGame","bubble","document","querySelector","table","numTilesRow","numTilesCol","window","screen","width","row","col","i","insertAdjacentHTML","querySelectorAll","forEach","r","j","generateTiles","tdAll","cats","Math","round","getRandomInt","minimum","maximum","min","ceil","max","floor","random","catsArray","tilesArray","Array","fill","createTilesArray","r2","createCatsArray","indexTile","tile","parentElement","rowIndex","cellIndex","changeClass","name","remove","classList","add","checkIfCatOnTile","b","catCounter","checkTileAndNeighbours","checkNextTile","nextTile","rows","cells","contains","indexArray","checkForNeighbouringCats","time","timer","updateTimer","innerHTML","flagsLeftCounter","flagsLeft","updateFlagsCounter","addEventListener","event","preventDefault","_event","innerText","setInterval","won","checkIfWon"],"mappings":"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","file":"main.js","sourcesContent":["let playing = false;\nlet newGame = true;\n\n// Speech bubble\nconst bubble = document.querySelector(\"#message\");\n// Table\nconst table = document.querySelector(\"#catsweeper\");\n\n// Generate tiles\nlet numTilesRow = 15;\nlet numTilesCol = 15;\n\n// Less tiles if small screen\nif (window.screen.width < 530) {\n  numTilesRow = 10;\n  numTilesCol = 10;\n}\n\nconst generateTiles = (row, col) => {\n  for (let i = 0; i < row; i += 1) {\n    table.insertAdjacentHTML(\"beforeend\", '<tr></tr>');\n  }\n\n  const tr = document.querySelectorAll(\"tr\");\n\n  tr.forEach((r) => {\n    for (let j = 0; j < col; j += 1) {\n      r.insertAdjacentHTML(\"beforeend\", '<td class=\"unopened\"></td>');\n    }\n  });\n};\n\ngenerateTiles(numTilesRow, numTilesCol);\n\n// Select all tiles\nconst tdAll = document.querySelectorAll(\"td\");\n\n// Set number of cats\nconst catsRatio = 0.1;\nconst cats = Math.round(catsRatio * (numTilesCol * numTilesRow));\n\n// Create grid/tiles array\nconst createTilesArray = () => {\n  const tilesArray = [];\n  for (let i = 0; i < numTilesRow; i += 1) {\n    tilesArray[i] = new Array(numTilesCol).fill(0);\n  }\n  return tilesArray;\n};\n\n// Create  random  integer\nconst getRandomInt = (minimum, maximum) => {\n  const min = Math.ceil(minimum);\n  const max = Math.floor(maximum);\n  // The maximum is exclusive and the minimum is inclusive\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\n// Place cats randomly in grid 2d array\nconst createCatsArray = () => {\n  const catsArray = createTilesArray();\n  let j = 0;\n  let r;\n  let r2;\n  while (j < cats) {\n    r = getRandomInt(0, numTilesRow);\n    r2 = getRandomInt(0, numTilesCol);\n    if (catsArray[r][r2] !== 1) {\n      catsArray[r][r2] = 1;\n      j += 1;\n    }\n  }\n  return catsArray;\n};\n\nconst catsArray = createCatsArray();\n\n\n// Index the tile\nconst indexTile = (tile) => {\n  const rowIndex = tile.parentElement.rowIndex;\n  const cellIndex = tile.cellIndex;\n  return [rowIndex, cellIndex];\n};\n\n// Add and remove class name\nconst changeClass = (tile, name, remove) => {\n  tile.classList.add(name);\n  tile.classList.remove(remove);\n};\n\n\nconst checkIfCatOnTile = (row, col, b) => {\n  let catCounter = b;\n  // Does tile exist?\n  if (catsArray[row] && catsArray[row][col]) {\n    if (catsArray[row][col] === 1) {\n      catCounter += 1;\n    }\n  }\n  return catCounter;\n};\n\nconst checkForNeighbouringCats = (tile) => {\n  const indexArray = indexTile(tile);\n  const row = indexArray[0];\n  const col = indexArray[1];\n  let b = 0;\n\n  b = checkIfCatOnTile(row, col - 1, b);\n  b = checkIfCatOnTile(row, col + 1, b);\n  b = checkIfCatOnTile(row - 1, col, b);\n  b = checkIfCatOnTile(row + 1, col, b);\n  b = checkIfCatOnTile(row + 1, col + 1, b);\n  b = checkIfCatOnTile(row - 1, col + 1, b);\n  b = checkIfCatOnTile(row + 1, col - 1, b);\n  b = checkIfCatOnTile(row - 1, col - 1, b);\n\n  changeClass(tile, `cat-neighbour-${b}`, \"unopened\");\n\n  if (b === 0) {\n    changeClass(tile, \"opened\", \"unopened\");\n    return true;\n  }\n};\n\n\nconst checkTileAndNeighbours = (tile) => {\n  // Check the surrounding tile recursion function\n  const checkNextTile = (row, col) => {\n    if (typeof catsArray[row] !== 'undefined' && typeof catsArray[row][col] !== 'undefined') {\n      const nextTile = table.rows[row].cells[col];\n      if (nextTile.classList.contains(\"unopened\") && !nextTile.classList.contains(\"flagged\")) {\n        checkTileAndNeighbours(nextTile);\n      }\n    }\n  };\n\n  const indexArray = indexTile(tile);\n  const row = indexArray[0];\n  const col = indexArray[1];\n  const noCatNeighbours = checkForNeighbouringCats(tile);\n  if (noCatNeighbours === true) {\n    checkNextTile(row, col - 1);\n    checkNextTile(row, col + 1);\n    checkNextTile(row - 1, col);\n    checkNextTile(row + 1, col);\n    checkNextTile(row + 1, col + 1);\n    checkNextTile(row - 1, col + 1);\n    checkNextTile(row + 1, col - 1);\n    checkNextTile(row - 1, col - 1);\n  }\n};\n\nlet time = 1;\nconst timer = document.querySelector(\"#timer\");\n\nconst updateTimer = () => {\n  if (playing === false) {\n    return false;\n  }\n  if (time < 10) {\n    timer.innerHTML = `00${time}`;\n  } else if (time < 100) {\n    timer.innerHTML = `0${time}`;\n  } else if (time < 1000) {\n    timer.innerHTML = `${time}`;\n  }\n  time += 1;\n};\n\nconst startTimer = () => {\n  setInterval(updateTimer, 1000);\n};\n\n\n// Cats left counter\nconst flagsLeftCounter = document.querySelector(\"#flags-left\");\nlet flagsLeft = cats;\n\nconst setFlagsCounter = () => {\n  if (cats < 10) {\n    flagsLeftCounter.innerHTML = `00${cats}`;\n  } else if (cats < 100) {\n    flagsLeftCounter.innerHTML = `0${cats}`;\n  } else {\n    flagsLeftCounter.innerHTML = `${cats}`;\n  }\n};\n\nsetFlagsCounter();\n\nconst updateFlagsCounter = () => {\n  if (flagsLeft > -1) {\n    if (flagsLeft < 10) {\n      flagsLeftCounter.innerHTML = `00${flagsLeft}`;\n    } else if (flagsLeft < 100) {\n      flagsLeftCounter.innerHTML = `0${flagsLeft}`;\n    } else if (flagsLeft < 1000) {\n      flagsLeftCounter.innerHTML = `${flagsLeft}`;\n    }\n  } else if (flagsLeft < 0) {\n    if (flagsLeft > -10) {\n      flagsLeftCounter.innerHTML = `-0${-1 * flagsLeft}`;\n    } else {\n      flagsLeftCounter.innerHTML = `-${-1 * flagsLeft}`;\n    }\n  }\n};\n\n// Check if the user has won the game\nconst checkIfWon = () => {\n  let won = true;\n\n  tdAll.forEach((tile) => {\n    const indexArray = indexTile(tile);\n    const row = indexArray[0];\n    const col = indexArray[1];\n\n    if ((tile.classList.contains(\"unopened\") || tile.classList.contains(\"flagged\")) && catsArray[row][col] !== 1) {\n      won = false;\n      return won;\n    }\n  });\n  return won;\n};\n\n// Add toys to all cats when won\nconst addFlagsWhenWon = () => {\n  tdAll.forEach((tile) => {\n    const indexArray = indexTile(tile);\n    const row = indexArray[0];\n    const col = indexArray[1];\n\n    if (catsArray[row][col] === 1) {\n      changeClass(tile, \"flagged\", \"unopened\");\n    }\n  });\n};\n\n// Show all cats when game over\nconst addCatsWhenGameOver = () => {\n  tdAll.forEach((tile) => {\n    const indexArray = indexTile(tile);\n    const row = indexArray[0];\n    const col = indexArray[1];\n\n    if (catsArray[row][col] === 1) {\n      changeClass(tile, \"cat\", \"unopened\");\n    }\n  });\n};\n\n// --------- Event listeners on all tiles -----------------\ntdAll.forEach((tile) => {\n  // right click event listener\n  tile.addEventListener(\"contextmenu\", (event) => {\n    event.preventDefault();\n\n    // if tile contains toy already, remove the toy\n    if (playing || newGame) {\n      if (tile.classList.contains(\"flagged\")) {\n        changeClass(tile, \"unopened\", \"flagged\");\n        flagsLeft += 1;\n        updateFlagsCounter();\n        // if its unopened without toy, add toy\n      } else if (tile.classList.contains(\"unopened\")) {\n        changeClass(tile, \"flagged\", \"unopened\");\n        flagsLeft -= 1;\n        updateFlagsCounter();\n      }\n    }\n  }, false);\n\n  // mouse down event listener\n  tile.addEventListener(\"mousedown\", (_event) => {\n    if (tile.classList.contains(\"unopened\") && (playing || newGame)) {\n      bubble.innerText = \"Hmm..\";\n    }\n  });\n\n  // mouse up event listener\n  tile.addEventListener(\"mouseup\", (_event) => {\n    if (tile.classList.contains(\"unopened\") && (playing || newGame)) {\n      bubble.innerText = \"Choose a tile\";\n    }\n  });\n\n  // left click event listener\n  tile.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n\n    if (newGame) {\n      if (!playing) {\n        startTimer();\n      }\n      playing = true;\n\n      // check if tiles has a cat\n      const indexArray = indexTile(tile);\n      const row = indexArray[0];\n      const col = indexArray[1];\n      if (catsArray[row][col] === 1 && !tile.classList.contains(\"flagged\")) {\n        addCatsWhenGameOver();\n        bubble.innerText = \"Game over!\";\n        timer.classList.add(\"bounce-effect\");\n        timer.classList.add(\"bg-red\");\n        playing = false;\n        newGame = false;\n      } else if (tile.classList.contains(\"unopened\") && !tile.classList.contains(\"flagged\")) {\n        checkTileAndNeighbours(tile);\n\n        if (checkIfWon()) {\n          addFlagsWhenWon();\n          bubble.innerText = \"You won!\";\n          timer.classList.add(\"bounce-effect\");\n          timer.classList.add(\"bg-blue\");\n          playing = false;\n          newGame = false;\n        }\n      }\n    }\n  });\n});\n"],"sourceRoot":""}